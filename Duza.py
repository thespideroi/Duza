import numpy as np
import pandas as pd
import requests
import time
import json
import os
import os.path as path
from datetime import datetime
import tkinter as tk
from tkinter.messagebox import showinfo
from tkinter import filedialog as fd
from tkinter.scrolledtext import ScrolledText
import re
from array import array
from base64 import b64encode, b64decode

def optionsWindow():
    # Hide the other tab's frames
    deckFrame.grid_forget()
    cubeFrame.grid_forget()
    debugFrame.grid_forget()
    # Enable the other buttons
    deckButton['state'] = tk.NORMAL
    cubeButton['state'] = tk.NORMAL
    debugButton['state'] = tk.NORMAL
    # Then grid the options frame and disable the options button
    optionsFrame.grid(row=1, column=0, columnspan=6, sticky="nsew", padx=10, pady=10)
    optionsButton['state'] = tk.DISABLED
    
# And similar functions for the other tab buttons
def deckWindow():
    optionsFrame.grid_forget()
    cubeFrame.grid_forget()
    debugFrame.grid_forget()
    optionsButton['state'] = tk.NORMAL
    cubeButton['state'] = tk.NORMAL
    debugButton['state'] = tk.NORMAL
    deckFrame.grid(row=1, column=0, columnspan=6, sticky="nsew", padx=10, pady=10)
    deckButton['state'] = tk.DISABLED
    
def cubeWindow():
    optionsFrame.grid_forget()
    deckFrame.grid_forget()
    debugFrame.grid_forget()
    optionsButton['state'] = tk.NORMAL
    deckButton['state'] = tk.NORMAL
    debugButton['state'] = tk.NORMAL
    cubeFrame.grid(row=1, column=0, columnspan=6, sticky="nsew", padx=10, pady=10)
    cubeButton['state'] = tk.DISABLED
    
def debugWindow():
    optionsFrame.grid_forget()
    deckFrame.grid_forget()
    cubeFrame.grid_forget()
    optionsButton['state'] = tk.NORMAL
    deckButton['state'] = tk.NORMAL
    cubeButton['state'] = tk.NORMAL
    debugFrame.grid(row=1, column=0, columnspan=6, sticky="nsew", padx=10, pady=10)
    debugButton['state'] = tk.DISABLED

def updateDB():
    with open('duzaDB.json', 'w') as f:
        f.write(requests.get('https://db.ygoprodeck.com/api/v7/cardinfo.php').text)
    # Make a new CSV database
    tk.messagebox.showinfo(message="Updating Database...")
    df = pd.read_json('duzaDB.json')
    # Drop all the columns we don't care about
    df = df['data'].apply(lambda x: pd.Series(eval(str(x)))).drop(columns=['type', 'desc', 'race', 'archetype', 
        'ygoprodeck_url', 'card_sets', 'card_prices', 'typeline', 'atk', 'def', 'attribute', 'linkmarkers', 
        'pend_desc', 'monster_desc', 'scale', 'banlist_info']).rename(columns={"humanReadableCardType": "type"})
    df['card_image'] = df['card_images'].apply(lambda x: x[0].get('image_url'))
    df = df.drop(columns=['card_images']).set_index('id')
    df.to_csv('duzaDB.csv', index=True)
    os.remove('duzaDB.json')
    tk.messagebox.showinfo(message="Update Complete")

def poolExportYDK():
    export = fd.asksaveasfilename(filetypes=(('YDK Files', '*.ydk'), ('Text Files', '*.txt'), ('All files', '*.*')), defaultextension=('YDK Files', '*.ydk'))
    try:
        with open(export, 'w') as out:
            # Clear the contents of the file if it already exists
            out.write('')
        with open(export, 'a', encoding="utf8") as out:
            out.write('# Generated by Duza\n')
            i = 0
            for line in deckText.get('1.0', tk.END).split('\n'):
                if len(line) == 0:
                    if i == 0:
                        # Move to the sideboard if the first blank line is encountered
                        out.write("!side\n")
                        i += 1
                    else:
                        # Otherwise finish the export
                        tk.messagebox.showinfo(message='Export Completed')
                        break
                else:
                    try:
                        # re.search to split the line into card quantity and card name
                        # Look up the card name's corresponding passcode and write it
                        #    equal to the listed quantity
                        for j in range(int(re.search("\A(\d+) (.+)\Z", line)[1])):
                            out.write(str(list(df[df['name'].apply(lambda x: x.__eq__(re.search("\A(\d+) (.+)\Z", line)[2]))].index)[0])+'\n')
                    except Exception:
                        tk.messagebox.showinfo(message='Error reading line: "'+line+'"')
                        break
    except Exception:
        # try-except to avoid the program crashing if the user cancels export
        print('')
        
def poolExportYDKe():
    main = []
    side = []
    extra = []
    i = 0
    for line in deckText.get('1.0', tk.END).split('\n'):
        if len(line) == 0:
            if i == 0:
                # Move to the sideboard if the first blank line is encountered
                i += 1
            else:
                # Otherwise finish the export
                break
        else:
            #try:
            if True:
                # re.search to split the line into card quantity and card name
                # Look up the card name's corresponding passcode and write it
                #    equal to the listed quantity
                for j in range(int(re.search("\A(\d+) (.+)\Z", line)[1])):
                    if list(df[df['name'].apply(lambda x: x.__eq__(re.search("\A(\d+) (.+)\Z", line)[2]))].frameType)[0] in ['fusion', 'synchro', 'xyz', 'link', 'fusion_pendulum', 'synchro_pendulum', 'xyz_pendulum']:
                        extra.append(list(df[df['name'].apply(lambda x: x.__eq__(re.search("\A(\d+) (.+)\Z", line)[2]))].index)[0])
                    elif i==0:
                        main.append(list(df[df['name'].apply(lambda x: x.__eq__(re.search("\A(\d+) (.+)\Z", line)[2]))].index)[0])
                    else:
                        side.append(list(df[df['name'].apply(lambda x: x.__eq__(re.search("\A(\d+) (.+)\Z", line)[2]))].index)[0])
            #except Exception:
                        #tk.messagebox.showinfo(message='Error reading line: "'+line+'"')
                        # i = 2
                        #break
    if i < 2:
        # Convert the lists of passcodes to YDKe
        # This code largely taken from Yugioh Domain Toolbox by DarknessCatt
        # https://github.com/DarknessCatt/Yugioh-Domain-Toolbox/
        encodedDecks = []

        for deck in [main, extra, side]:
            idList = array("I", [card for card in deck])
            b64str = b64encode(idList.tobytes()).decode("ascii")
            encodedDecks.append(b64str)

        ydkeOut.delete('1.0', tk.END)
        ydkeOut.insert('1.0', "ydke://" + '!'.join(encodedDecks) + '!')
        tk.messagebox.showinfo(message='Export Completed')

def importCube():
    # Load a file and insert its contents into the cubeText widget
    f = fd.askopenfile(filetypes=(('All supported files', ['*.csv', '*.ydk', '*.txt']), ('CSV files', '*.csv'), ('YDK files', ['*.ydk', '*.txt']), ('All files', '*.*')))
    try:
        cubeText.delete('1.0', tk.END)
        #cubeText.insert('1.0', ''.join(f.readlines()))
        if f.name[-4:] in ('.txt', '.ydk'):
            cubeText.insert('1.0', ''.join(f.readlines()))
        else:
            #cubeText.insert('1.0', '#CSV\n')
            print()
            for i, r in pd.read_csv(f.name, names=['passcode', 'name', 'type', 'count']).iterrows():
                
                for j in range(int(r['count'])):
                    cubeText.insert(tk.END, str(r.passcode)+'\n')
    except Exception:
        # Clear the widget if the file doesn't import
        cubeText.delete('1.0', tk.END)
  
def exportCube():
    export = fd.asksaveasfilename(filetypes=(('Text Files', '*.txt'), ('All files', '*.*')), defaultextension=('Text Files', '*.txt'))
    packsize = 15
    try:
        with open(export, 'w') as out:
            # Clear the contents of the file if it already exists
            out.write('')
        with open(export, 'a', encoding="utf8") as out:
            out.write('[CustomCards]\n[\n')
            counts={}
            for line in cubeText.get('1.0', tk.END).split('\n'):
                if not(len(line) == 0 or line[0] == '#' or line == '!side'):
                    passcode = int(line)# if cubeText.get('1.0', '1.4') == '#YDK' else int()
                    if passcode in df.index:
                        # If this is the first copy of the card encountered:
                        if not (passcode in counts.keys()):
                            counts[passcode] = 1
                                # Write the card's name
                            out.write('{"name":"'+df.loc[passcode]['name'].replace('"', '\\\"')+
                                # Mana cost equal to its Level/Link Rating
                                '","mana_cost":"{'+str((0 if np.isnan(df.loc[passcode].level) else int(df.loc[passcode].level)) if np.isnan(df.loc[passcode].linkval) else int(df.loc[passcode].linkval))+
                                # Main Deck Monsters and Spells are encoded as Creatures
                                '}","type":"'+(df.loc[passcode].type.replace('Monster', 'Creature') if df.loc[passcode].frameType in ['effect', 'normal', 'effect_pendulum', 'normal_pendulum'] else df.loc[passcode].type.replace('Spell', 'Creature'))+
                                # Assign it a color based on certain characteristics
                                '","colors":['+(
                                    '"W"' if df.loc[passcode].frameType in ['effect', 'normal', 'effect_pendulum', 'normal_pendulum'] and df.loc[passcode].level < 4
                                    else '"U"' if df.loc[passcode].frameType in ['effect', 'normal', 'effect_pendulum', 'normal_pendulum'] and df.loc[passcode].level == 4
                                    else '"B"' if df.loc[passcode].frameType in ['effect', 'normal', 'effect_pendulum', 'normal_pendulum'] and df.loc[passcode].level > 4
                                    else '"R"' if df.loc[passcode].frameType == 'spell'
                                    else '"G"' if df.loc[passcode].frameType == 'trap'
                                    else ''
                                # Its YGOPRODeck image link
                                )+'],"image_uris": {"en":"'+df.loc[passcode].card_image+'"}},\n')
                        # Else note an extra copy of it
                        else:
                            counts[passcode] = counts.get(passcode) + 1
                    else:
                        # Notify the user if a problematic passcode is encountered
                        tk.messagebox.showinfo(message='Passcode '+line[:-1]+' not found!')
                        break
            out.write(']\n[MainSlot('+str(packsize)+')]\n')
            # Write the number of copies of each card into the pack slots
            for i in counts:
                for j in range(counts.get(i)):
                    out.write(df.loc[i]['name'].replace('"', '\"')+'\n')
            tk.messagebox.showinfo(message='Export Completed')
    except Exception:
        # try-except to avoid the program crashing if the user cancels export
        print('')
   
def exportCobra():
    export = fd.asksaveasfilename(filetypes=(('CSV Files', '*.csv'), ('All files', '*.*')), defaultextension=('CSV Files', '*.csv'))
    try:
        with open(export, 'w') as out:
            # Clear the contents of the file if it already exists
            out.write('')
        with open(export, 'a', encoding="utf8") as out:
            out.write('name,CMC,Type,Color,Set,Collector Number,Rarity,Color Category,status,Finish,maybeboard,image URL,image Back URL,tags,Notes,MTGO ID\n')
            for line in cubeText.get('1.0', tk.END).split('\n'):
                if not(len(line) == 0):
                    passcode = int(line)
                    if passcode in df.index:
                            # Encode the card as a Wastes with a custom color, mana cost, and image
                            # Mana cost equal to its Level/Link Rating
                        out.write('"Wastes",'+str((0 if np.isnan(df.loc[passcode].level) else int(df.loc[passcode].level)) if np.isnan(df.loc[passcode].linkval) else int(df.loc[passcode].linkval))
                                # Main Deck Monsters and Spells are encoded as Creatures
                                +',"'+(df.loc[passcode].type.replace('Monster', 'Creature') if df.loc[passcode].frameType in ['effect', 'normal', 'effect_pendulum', 'normal_pendulum'] else df.loc[passcode].type)
                                # Assign it a color based on certain characteristics
                                +'",'+('"W"' if df.loc[passcode].frameType in ['effect', 'normal', 'effect_pendulum', 'normal_pendulum'] and df.loc[passcode].level < 4
                                else '"U"' if df.loc[passcode].frameType in ['effect', 'normal', 'effect_pendulum', 'normal_pendulum'] and df.loc[passcode].level == 4
                                else '"B"' if df.loc[passcode].frameType in ['effect', 'normal', 'effect_pendulum', 'normal_pendulum'] and df.loc[passcode].level > 4
                                else '"R"' if df.loc[passcode].frameType == 'spell'
                                else '"G"' if df.loc[passcode].frameType == 'trap'
                                # Its YGOPRODeck image link
                                else '')+',"ogw","184a",common,Lands,Owned,Non-foil,false,"'+df.loc[passcode].card_image+'",,"","'+
                                # Its name as a Note
                                str(df.loc[passcode]['name']).replace('"', '')+'",\n')
                    else:
                         # Notify the user if a problematic passcode is encountered
                         tk.messagebox.showinfo(message='Passcode '+line[:-1]+' not found!')
                         break
            tk.messagebox.showinfo(message='Export Completed')
    except Exception:
        # try-except to avoid the program crashing if the user cancels export
        print('')   

def passSearch():
    try:
        # Print the name field of the Dataframe row with the passcode's index
        debugOut.config(text=df.loc[int(passField.get('1.0', tk.END))]['name'])
    except Exception:
        debugOut.config(text="Passcode not found!")

def nameSearch():
    try:
        # Query returns a list of all indices for which the card's name is the input
        # I'm not actually certain if YGOPRODeck's database has multiple passcodes 
        #   per card but EDOPro does so we're just being safe
        query = list(df[df['name'].apply(lambda x: x.__eq__(passField.get('1.0', tk.END)[:-1]))].index)
        debugOut.config(text=str(query) if len(query)>0 else "Name not found!")
    except Exception:
        debugOut.config(text="Name not found!")

# Main code starts here
dbOK = False
try:
    # Refresh the database if it's 30 days out of date or the CSV database doesn't exist
    if time.time() - path.getmtime('duzaDB.csv') > 2592000:
        with open('duzaDB.json', 'w') as f:
            f.write(requests.get('https://db.ygoprodeck.com/api/v7/cardinfo.php').text)
    else:
        dbOK = True
except Exception:
    # Create the database if cards.json doesn't exist
    with open('duzaDB.json', 'w') as f:
        f.write(json.dumps(requests.get('https://db.ygoprodeck.com/api/v7/cardinfo.php').json()))

# Create the main window
root = tk.Tk()
root.title("Duza the Cubic Vessel")
root.minsize(400, 300)
root.geometry("720x540+100+100")

if not dbOK:
    # Make a new CSV database
    tk.messagebox.showinfo(message="Database out of date or does not exist, creating a new one...")
    df = pd.read_json('duzaDB.json')
    # Drop all the columns we don't care about
    df = df['data'].apply(lambda x: pd.Series(eval(str(x)))).drop(columns=['type', 'desc', 'race', 'archetype', 
        'ygoprodeck_url', 'card_sets', 'card_prices', 'typeline', 'atk', 'def', 'attribute', 'linkmarkers', 
        'pend_desc', 'monster_desc', 'scale', 'banlist_info']).rename(columns={"humanReadableCardType": "type"})
    df['card_image'] = df['card_images'].apply(lambda x: x[0].get('image_url'))
    df = df.drop(columns=['card_images']).set_index('id')
    df.to_csv('duzaDB.csv', index=True)
    os.remove('duzaDB.json')
else:
    df = pd.read_csv("duzaDB.csv")
    df = df.set_index('id')

root.rowconfigure(0, weight=0, minsize=1)
root.rowconfigure(1, weight=1)
root.columnconfigure(0, weight=1)

tabs = tk.Frame(root)
for i in range(6):
    tabs.columnconfigure(i, weight=1)
   
optionsButton = tk.Button(tabs, text="Options", command=optionsWindow, state=tk.NORMAL)
optionsButton.grid(row=0, column=0, columnspan=1, sticky="ew")
deckButton = tk.Button(tabs, text="Deck Translator", command=deckWindow, state=tk.DISABLED)
deckButton.grid(row=0, column=1, columnspan=2, sticky="ew")
cubeButton = tk.Button(tabs, text="Cube Translator", command=cubeWindow, state=tk.NORMAL)
cubeButton.grid(row=0, column=3, columnspan=2, sticky="ew")
debugButton = tk.Button(tabs, text="Debugger", command=debugWindow, state=tk.NORMAL)
debugButton.grid(row=0, column=5, columnspan=1, sticky="ew")
tabs.grid(row=0, column=0, sticky='ew')
 
# Set up the tabs
optionsFrame = tk.Frame(root)
deckFrame = tk.Frame(root)
cubeFrame = tk.Frame(root)
debugFrame = tk.Frame(root)

for i in [optionsFrame, deckFrame, cubeFrame, debugFrame]:
    # Configure a 4x6 grid in each tab
    for j in range(4):
        i.columnconfigure(j, weight=1)
    for j in range(6):
        i.rowconfigure(j, weight=1, minsize=40)

# Options Frame
tk.Button(optionsFrame, text="Manual DB Update", command=updateDB).grid(row=0, column=0, columnspan=4)

# Deck Translator Frame
deckText = ScrolledText(deckFrame)
deckText.grid(row=0, column=0, columnspan=4, rowspan=4, padx=10, sticky='nsew')
tk.Button(deckFrame, text="Export YDK", command=poolExportYDK).grid(row=4, column=0, columnspan=2)
tk.Button(deckFrame, text="Export YDKe", command=poolExportYDKe).grid(row=4, column=2, columnspan=2)
ydkeOut = tk.Text(deckFrame, height=1, width=18)
ydkeOut.grid(row=5, column=2, columnspan=2)

# Cube Translator Frame
tk.Button(cubeFrame, text="Import File", command=importCube).grid(row=0, column=0)

# importType = tk.StringVar()
# importRadio = tk.Frame(cubeFrame)
# importRadio.rowconfigure(0, weight=1)
# importRadio.rowconfigure(1, weight=1)
# tk.Radiobutton(importRadio, text="CSV (YGOPRODeck)", value='csv', variable=importType).grid(row=0, column=0, sticky='w')
# tk.Radiobutton(importRadio, text="YDK / TXT", value='ydk', variable=importType).grid(row=1, column=0, sticky='w')
# importRadio.grid(row=0, column=1, columnspan=3, sticky='w')

tk.Label(cubeFrame, anchor="e", text="Pack Size:").grid(row=0, column=2)
packSize = tk.Text(cubeFrame, height=1, width=3)
packSize.insert('1.0', "15")
packSize.grid(row=0, column=3, sticky="w")
cubeText = ScrolledText(cubeFrame)
cubeText.grid(row=1, column=0, columnspan=4, rowspan=4, padx=10, pady=10, sticky='nsew')
# tk.Button(cubeFrame, text="Export CSV").grid(row=5, column=0)
# tk.Button(cubeFrame, text="Export YDK").grid(row=5, column=1)
tk.Button(cubeFrame, text="Export Draftmancer", command=exportCube).grid(row=5, column=2, columnspan=2)
tk.Button(cubeFrame, text="Export CubeCobra", command=exportCobra).grid(row=5, column=0, columnspan=2)

# Debug Frame
passField = tk.Text(debugFrame, height=1)
passField.grid(row=0, column=0, columnspan=4, padx=10, pady=10)
tk.Button(debugFrame, text="Search by Passcode", command=passSearch).grid(row=1, column=0, columnspan=2, padx=5)
tk.Button(debugFrame, text="Search by Name", command=nameSearch).grid(row=1, column=2, columnspan=2, padx=5)
debugOut = tk.Label(debugFrame, anchor="w")
debugOut.grid(row=2, column=0, columnspan=4, padx=10)


deckFrame.grid(row=1, column=0, sticky="nsew", padx=10, pady=10)

root.mainloop()
